// app/api/translate/route.ts

import { NextResponse } from "next/server";
import { TRANSLATION_SYSTEM_PROMPT, buildUserPrompt } from "../../../lib/translationPrompt";

/** ✅ 대사 위/아래 빈 줄 강제 */
function normalizeDialogueSpacing(text: string) {
  const lines = text.replace(/\r\n/g, "\n").split("\n");

  const isDialogueLine = (s: string) => {
    const t = s.trim();
    return t.startsWith('"') || t.startsWith("「") || t.startsWith("『");
  };

  const out: string[] = [];
  for (let i = 0; i < lines.length; i++) {
    const cur = lines[i] ?? "";
    const t = cur.trimEnd();

    if (isDialogueLine(t)) {
      if (out.length > 0 && out[out.length - 1].trim() !== "") out.push("");
      out.push(t);
      if (i < lines.length - 1 && (lines[i + 1] ?? "").trim() !== "") out.push("");
    } else {
      out.push(cur);
    }
  }

  return out.join("\n").replace(/\n{3,}/g, "\n\n").trimEnd();
}

/** ✅ “문장 끝 공백 1칸” 강제 */
function ensureTrailingSpacePerLine(text: string) {
  const lines = text.replace(/\r\n/g, "\n").split("\n");
  return lines
    .map((l) => {
      if (l.trim() === "") return "";
      return l.endsWith(" ") ? l : l + " ";
    })
    .join("\n");
}

/** ✅ 원문 상단이 "#숫자" 형태인지 판단 */
function extractLeadingHashChapter(source: string) {
  const lines = source.replace(/\r\n/g, "\n").split("\n");
  for (let i = 0; i < Math.min(lines.length, 12); i++) {
    const t = (lines[i] ?? "").trim();
    if (!t) continue;
    if (/^#\d{1,4}$/.test(t)) return t; // "#1" "#01"
    // 첫 의미있는 줄이 "#..."가 아니면 중단
    break;
  }
  return null;
}

/** ✅ "제 N화" / "第N話" / "N화" 같은 회차 헤더 라인인지 */
function isEpisodeHeaderLine(line: string) {
  const t = line.trim();
  if (!t) return false;
  if (/^제\s*\d+\s*화$/.test(t)) return true;
  if (/^第\s*\d+\s*話$/.test(t)) return true;
  if (/^\d+\s*화$/.test(t)) return true;
  return false;
}

/**
 * ✅ 핵심: 원문이 "#1/#01"인데 번역 상단에 "제 1화" 같은 헤더를 새로 만들어 붙이면 제거
 * - 원문 #숫자와 같은 숫자일 때만 제거(오탐 방지)
 */
function removeAutoGeneratedEpisodeHeaderWhenSourceIsHash(source: string, translated: string) {
  const hash = extractLeadingHashChapter(source);
  if (!hash) return translated;

  const n = parseInt(hash.replace("#", ""), 10);
  if (!Number.isFinite(n)) return translated;

  const lines = translated.replace(/\r\n/g, "\n").split("\n");

  // 상단 공백 스킵
  let i = 0;
  while (i < lines.length && lines[i].trim() === "") i++;

  // 상단에 "제 N화"가 있으면, N이 같을 때 제거
  // + 그 주변 빈 줄도 정리
  if (i < lines.length && isEpisodeHeaderLine(lines[i])) {
    const header = lines[i].trim();

    const numMatch =
      header.match(/^제\s*(\d+)\s*화$/) ||
      header.match(/^第\s*(\d+)\s*話$/) ||
      header.match(/^(\d+)\s*화$/);

    const m = numMatch ? parseInt(numMatch[1], 10) : NaN;

    if (Number.isFinite(m) && m === n) {
      // 제거
      lines.splice(i, 1);

      // 바로 뒤 공백 1~2줄 정리
      while (i < lines.length && lines[i].trim() === "") {
        lines.splice(i, 1);
      }
    }
  }

  return lines.join("\n").trimStart();
}

/** ✅ 헤더(회차/부제목)와 본문 사이 간격 넓히기: 빈 줄 2개 보장 */
function widenHeaderToBodyGap(text: string) {
  const lines = text.replace(/\r\n/g, "\n").split("\n");

  const isHeaderLike = (line: string) => {
    const t = line.trim();
    if (!t) return false;

    // "#1/#01"
    if (/^#\d{1,4}$/.test(t)) return true;
    // "제 1화/第1話/1화"
    if (/^제\s*\d+\s*화$/.test(t) || /^第\s*\d+\s*話$/.test(t) || /^\d+\s*화$/.test(t)) return true;

    // 부제목 후보: 짧고 종결부호로 끝나지 않으면 헤더 취급
    if (t.length <= 40 && !/[。.!?]$/.test(t)) return true;

    return false;
  };

  // 상단 공백 스킵
  let i = 0;
  while (i < lines.length && lines[i].trim() === "") i++;

  // 헤더 블록(최대 6라인) 끝 찾기
  let end = i;
  let headerCount = 0;
  while (end < lines.length && headerCount < 6) {
    const t = (lines[end] ?? "").trim();
    if (t === "") {
      end++;
      continue;
    }
    if (isHeaderLike(lines[end])) {
      headerCount++;
      end++;
      continue;
    }
    break;
  }

  if (headerCount === 0 || end >= lines.length) return text;

  // end 직전 공백 제거
  while (end > 0 && lines[end - 1].trim() === "") {
    lines.splice(end - 1, 1);
    end--;
  }

  // 본문 앞에 빈 줄 2개
  lines.splice(end, 0, "", "");

  return lines.join("\n").replace(/\n{5,}/g, "\n\n\n\n").trimEnd();
}

export async function POST(req: Request) {
  try {
    const { text } = await req.json();
    const input = String(text ?? "");
    if (!input.trim()) return NextResponse.json({ translated: "" });

    const openaiRes = await fetch(
      process.env.OPENAI_API_URL ?? "https://api.openai.com/v1/chat/completions",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${process.env.OPENAI_API_KEY}`,
        },
        body: JSON.stringify({
          model: process.env.OPENAI_MODEL ?? "gpt-4o-mini",
          temperature: 0.2,
          messages: [
            { role: "system", content: TRANSLATION_SYSTEM_PROMPT },
            { role: "user", content: buildUserPrompt(input) },
          ],
        }),
      }
    );

    if (!openaiRes.ok) {
      const raw = await openaiRes.text().catch(() => "");
      return NextResponse.json(
        { error: `OpenAI error: ${openaiRes.status} ${openaiRes.statusText}\n${raw}` },
        { status: 500 }
      );
    }

    const data = await openaiRes.json();
    let translated =
      data?.choices?.[0]?.message?.content ??
      data?.output_text ??
      "";

    translated = String(translated ?? "");

    // ✅ 1) 원문이 "#1"인데 모델이 "제 1화"를 새로 만든 경우 제거
    translated = removeAutoGeneratedEpisodeHeaderWhenSourceIsHash(input, translated);

    // ✅ 2) 서식 후처리
    translated = normalizeDialogueSpacing(translated);
    translated = widenHeaderToBodyGap(translated);
    translated = ensureTrailingSpacePerLine(translated);

    return NextResponse.json({ translated });
  } catch (e: any) {
    return NextResponse.json({ error: e?.message || "translate failed" }, { status: 500 });
  }
}
